from __future__ import annotations

from copy import deepcopy
from typing import Dict, List, Union

import pandas as pd
from sqlalchemy import and_, select, Table, func, desc
from sray_db.psql.util import temptable_from_idx
from sray_db.apps.pk import PrimaryKey


class WideTable:

    def __init__(self, table: Table,
                 field_column_map: Dict['Field',PrimaryKey],
                 hierarchy: str = 'security',
                 ):
        self.table = table
        self.field_column_map = field_column_map
        self.hierarchy = hierarchy

    @property
    def primary_keys(self) -> List[PrimaryKey]:
        return [f for f in self.field_column_map.keys() if isinstance(f, PrimaryKey)]

    @property
    def fields(self) -> List['Field']:
        return [f for f in self.field_column_map.keys() if not isinstance(f, PrimaryKey)]

    @property
    def name(self) -> str:
        return self.table.name

    def copy(self):
        return deepcopy(self)

    def join(self, tables: List[WideTable], fields: List[List['Field']],
             isouter: bool = False, full: bool = False,
             alias: str = None) -> WideTable:

        join_ = self.table

        for i, t in enumerate(tables):
            union_pks = set(self.primary_keys).intersection(t.primary_keys)
            join_on = and_(*[self.field_column_map[pk] == t.field_column_map[pk] for pk in union_pks])
            join_ = join_.join(t.table, join_on, isouter, full)

        selected_columns = {}
        for pk in self.primary_keys:
            selected_columns[pk] = self.field_column_map[pk]

        for i, f in enumerate(fields):
            tbl = ([self] + tables)[i]
            for f_ in f:
                selected_columns[f_] = tbl.field_column_map[f_]

        cols = list(selected_columns.values())
        new_tbl = select(cols).select_from(join_).alias(alias)

        field_column_map = {f:new_tbl.c[col.name] for f, col in selected_columns.items()}

        return WideTable(new_tbl,
                         field_column_map,
                         self.hierarchy)

    def get_filtered_table(self, as_of: Union[pd.Timestamp, None]) -> WideTable:
        """
        Filter the table by returning only the most recently created (before the `as_of` date, if defined) resultset
        (partitioned by all of the Primary Keys)

        :param as_of: If defined, will not return results with a date_created later than the `as_of` date
        :return: WideTable containing only the most recently created (before the `as_of` date, if defined) resultset
                 (partitioned by all of the Primary Keys)
        """

        date_created_col = self.field_column_map[self._get_date_created_field()]
        pk_cols = [self.field_column_map[pk] for pk in self.primary_keys]
        rn = func.row_number().over(partition_by=pk_cols, order_by=desc(date_created_col)).label('rn')

        unfiltered = select(self.table.columns + [rn]).select_from(self.table)
        if as_of is not None:
            as_of = pd.Timestamp(as_of)
            unfiltered = unfiltered.where((date_created_col <= as_of))
        unfiltered = unfiltered.alias('u')

        cols = [unfiltered.columns[c.name] for c in self.table.columns]
        filtered = select(cols).select_from(unfiltered).where((unfiltered.columns['rn'] == 1)).alias('f')

        field_column_map = {key: filtered.columns[key.name.lower()] for key in self.primary_keys + self.fields}

        wide_table = WideTable(filtered, field_column_map, self.hierarchy)

        return wide_table

    def select_fields(self, fields):

        cols = [self.field_column_map[f] for f in fields]

        s = select(cols).select_from(self.table)

        return s

    def to_primary(self):
        from sray_db.psql.interface import PSQLTable
        from sray_db.apps import apps

        entity_app = apps['assetinfo_entity'][(1, 0, 0, 0)]
        primary_field = entity_app['primary_assetid']
        entity_table = PSQLTable.from_app(entity_app).table.table.alias('pm')

        join_on = (self.table.c[PrimaryKey.assetid.value] == entity_table.c[PrimaryKey.assetid.value])
        joined = self.table.join(entity_table, join_on)

        cols = []
        for col in self.table.columns:
            if col.name == PrimaryKey.assetid.value:
                cols.append(entity_table.c[primary_field.name].label(PrimaryKey.assetid.value))
            else:
                cols.append(self.table.c[col.name])

        tbl = select(cols).select_from(joined).alias(f'{self.table.name}_p')

        new_ = self.copy()
        new_.table = tbl
        new_.field_column_map = {key: tbl.columns[key.name.lower()] for key in self.primary_keys + self.fields}

        return new_

    def inner_join_indices(self, indices: List[pd.MultiIndex],
                           alias: str = None) -> WideTable:

        tables = self._widetables_from_indices(indices)
        fields = [self.fields] + ([[]] * len(tables))
        joined = self.join(tables, fields, isouter=False, alias=alias)

        return joined

    def _get_date_created_field(self) -> 'Field':
        matching_fields = [field for field in self.field_column_map if field.name == 'date_created']
        if len(matching_fields) == 1:
            return matching_fields[0]
        else:
            raise ValueError(f'WideTable on {self.table} contains {len(matching_fields)} date_created fields, needs to '
                             f'be exactly 1')

    def _widetable_from_idx(self, idx: pd.MultiIndex, name: str) -> Union[None, WideTable]:
        """Creates WideTables from an Index or returns None if there are no matching primary keys between
        the Index and self (e.g. when self only has PrimaryKey.assetid and idx only has PrimaryKey.date"""

        for pk in idx.names:
            if pk not in self.primary_keys:
                level = idx.names.index(pk)
                if len(idx.names) > 1:
                    idx = idx.droplevel(level).unique()
                else:
                    return None

        t_tbl = temptable_from_idx(idx, self.table.bind)

        t_tbl = t_tbl.alias(name)
        table = WideTable(t_tbl,
                          {pk: t_tbl.c[pk.value] for pk in idx.names},
                          None)

        return table

    def _widetables_from_indices(self, indices: List[pd.MultiIndex]) -> List[WideTable]:

        widetables = []
        for i, idx in enumerate(indices):
            widetable = self._widetable_from_idx(idx, f'r_idx_{i}')
            if widetable is not None:
                widetables.append(widetable)

        return widetables
