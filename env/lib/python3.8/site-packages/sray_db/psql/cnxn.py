import logging

import sqlalchemy
from sqlalchemy import MetaData
from sqlalchemy.engine import Engine
from threading import Lock

from sray_db import config

lock = Lock()

_ENGINES = {}
_META = {}


def get_engine(database: str = None,
               force_new: bool = False) -> Engine:
    database = database or config['SRAYDB_SQL_DATABASE']

    connect_args = {
        'application_name': config['SRAYDB_SQL_APPLICATION_NAME']
    }

    with_ssl = False
    if config['SRAYDB_SQL_USE_SSL'] == '1':
        with_ssl = True
        connect_args = {
            **connect_args,
            'sslmode': config['SRAYDB_SQL_SSLMODE'],
            'sslrootcert': config['SRAYDB_SQL_SSLROOTCERT'],
            'sslkey': config['SRAYDB_SQL_SSLKEY'],
            'sslcert': config['SRAYDB_SQL_SSLCERT']
        }

    exists = database in _ENGINES
    if not exists or force_new:
        host = config['SRAYDB_SQL_HOST']
        port = config['SRAYDB_SQL_PORT']
        username = config['SRAYDB_SQL_USERNAME']

        logging.debug(f'Connecting to {username}@{host}:{port} (with ssl: {with_ssl})')

        engine = sqlalchemy.create_engine(
            sqlalchemy.engine.url.URL(
                drivername=config['SRAYDB_SQL_DRIVERNAME'],
                username=username,
                password=config['SRAYDB_SQL_PASSWORD'],
                database=database,
                host=host,
                port=port),
            pool_size=config['SRAYDB_SQL_POOL_SIZE'],
            max_overflow=config['SRAYDB_SQL_MAX_OVERFLOW'],
            pool_timeout=config['SRAYDB_SQL_POOL_TIMEOUT'],
            pool_recycle=config['SRAYDB_SQL_POOL_RECYCLE'],
            connect_args=connect_args,
            use_batch_mode=config['SRAYDB_SQL_USE_BATCH_MODE'])
    else:
        engine = _ENGINES[database]

    if not exists and not force_new:
        _ENGINES[database] = engine

    return engine


def get_meta(engine: Engine, schema: str = None, force_new: bool = False) -> MetaData:

    engine_exists = engine in _META
    meta_exists = engine_exists and schema in _META[engine]

    if not meta_exists or force_new:
        meta = MetaData(bind=engine, schema=schema)
    else:
        meta = _META[engine][schema]

    if not meta_exists and not force_new:
        if not engine_exists:
            _META[engine] = {}
        _META[engine][schema] = meta

    return meta
