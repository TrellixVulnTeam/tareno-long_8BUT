# -*- coding: utf-8 -*-
import logging
import typing

import yaml

log = logging.getLogger(__name__)


class AppConfig():
    @staticmethod
    def validate_required_elements(data, required_elements):
        for element in required_elements:
            AppConfig.validate_string(element)
            if element not in data:
                raise ValueError(f"Data object does not have all required elements: {required_elements}.")
        return True 
    
    @staticmethod
    def return_optional_elements(data, optional_elements):
        return [element for element in optional_elements if element in data]
    
    @staticmethod
    def validate_string(string):
        assert type(string) == str
        assert len(string) > 0
        return True
    
    @staticmethod
    def validate_positive_int_from_string(number):
        assert type(int(number)) == int
        assert number >-1
        return True
    
    @staticmethod
    def validate_version_style(version):
        elements = ['build', 'major', 'minor', 'revision']
        AppConfig.validate_required_elements(version, required_elements=elements)
        for element in elements:
            AppConfig.validate_positive_int_from_string(version[element])
    
    @staticmethod
    def parse_version_dict(version):
        return int(version['major']), int(version['minor']), int(version['build']), int(version['revision'])
    
    @staticmethod
    def validate_frequency(frequency):
        AppConfig.validate_string(frequency)
        assert frequency in ['Adhoc', 'Hourly', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Yearly']
        return True

    @staticmethod
    def validate_forbidden_names(field_name: str, forbidden_names: typing.List[str]):
        assert field_name not in forbidden_names, f'field_name {field_name} is not allowed'
        return True
    
    @staticmethod
    def validate_outputs(outputs):
        assert type(outputs) == list
        return all(AppConfig.validate_output(output) for output in outputs)
    
    @staticmethod
    def validate_output(output):
        AppConfig.validate_forbidden_names(output['field_name'], forbidden_names=['date_created', 'load_cutoff'])
        AppConfig.validate_required_elements(output, required_elements=['field_name', 'primary_key', 'type'])
        AppConfig.validate_string(output['field_name'])
        AppConfig.validate_boolean_string(output['primary_key'])
        AppConfig.validate_string(output['type'])
        
        opts = AppConfig.return_optional_elements(output, ['uses'])
        if 'uses' in opts:
            assert type(output['uses']) == list
            return all(AppConfig.validate_input_app(input_app) for input_app in output['uses'])
        else:
            return True
    
    @staticmethod
    def validate_boolean_string(value):
        assert type(value) == bool
        return True
    
    @staticmethod
    def validate_input_app(app):
        AppConfig.validate_required_elements(app, required_elements=['app_name', 'version', 'fields'])
        AppConfig.validate_string(app['app_name'])
        AppConfig.validate_version_style(app['version'])
        assert type(app['fields']) == list
        for inp in app['fields']:
            AppConfig.validate_string(inp["field_name"])
    
    @staticmethod
    def validate_config(config):
        AppConfig.validate_required_elements(config, required_elements=['app_name', 'description', 'frequency',
                                                                        'version', 'outputs'])
        AppConfig.validate_string(config['app_name'])
        AppConfig.validate_string(config['description'])
        AppConfig.validate_frequency(config['frequency'])
        AppConfig.validate_version_style(config['version'])
        AppConfig.validate_outputs(config['outputs'])

    @staticmethod
    def read_yaml(file):
        with open(file, 'r') as stream:
            try:
                return yaml.safe_load(stream)
            except yaml.YAMLError as exc:
                log.exception(exc)
                return None
    
    def __init__(self, config_file):
        # Set config path
        self.config_path = config_file
        
        # Try to read yaml file
        config = AppConfig.read_yaml(self.config_path)
        
        # Make sure it was read
        if config is None:
            raise ValueError(f"Config at path {self.config_file} could not be loaded.")
        
        # Validate required and optional fields
        AppConfig.validate_config(config)
        
        # Set original config
        self.config_file = config
        
        # Set fields and deducted fields
        self.name = config['app_name']
        self.description = config['description']
        self.frequency = config['frequency']
        self.hierarchy = config['hierarchy']
        
        self.version = AppConfig.parse_version_dict(config['version'])
        self.version_string = '_'.join([str(i) for i in self.version])
        
        self.id = self.name + self.version_string
        self.id_tuple = (self.name, self.version)
        
        # Parse outputs and keep track of what fields we are producing, what apps we need and what the uses dict is per
        # output field
        self.field_dicts = []
        self.primary_keys = []
        self.apps = set()
        self.input_map = {}
        for output in config['outputs']:
            if output['primary_key'] is True:
                self.primary_keys.append(output['field_name'])
            else:
                self.field_dicts.append(output)
                if 'uses' in output:
                    self.input_map[output['field_name']] = output['uses']
                    for app in output['uses']:
                        self.apps.add((app['app_name'], AppConfig.parse_version_dict(app['version'])))
    
    def __repr__(self):
        return (self.__class__.__qualname__ +
            f"(name={self.name}, version={self.version}, path={self.config_path})")
