import inspect
from typing import Dict, List, Tuple

import pandas as pd
from prometheus_client import Counter
from sray_db.apps.pk import PrimaryKey
from structlog import get_logger

from arabesque_py.prometheus.prometheus import Prometheus
from arabesque_py.score_validation.validator import Validator

log = get_logger()


class LongTotalValidator(Validator):
    coverage_threshold: float
    abs_diff_threshold: float
    upper_limit: float
    lower_limit: float
    override_checks: List[str]

    def __init__(
        self,
        app_name: str,
        prometheus: Prometheus,
        coverage_threshold: float = 0.1,
        abs_diff_threshold: float = 50,
        upper_limit: float = 100,
        lower_limit: float = 0,
        override_checks: List[str] = [],
    ):
        self.upper_limit = upper_limit
        self.lower_limit = lower_limit
        self.override_checks = override_checks
        self.coverage_threshold = coverage_threshold
        self.abs_diff_threshold = abs_diff_threshold
        super().__init__(app_name, prometheus)

    def check_coverage(
        self, previous_df: pd.DataFrame, current_df: pd.DataFrame
    ) -> Tuple[bool, int]:
        """
        This function gets the number of assets from the previous calculation and compares
        with the current calculation.
        If the percentag difference is above a threshold it returns a False along with the difference.
        Otherwise it returns True with the difference

        Args:
            previous_df (pd.DataFrame): previous calculation
            current_df (pd.DataFrame): current calculation

        Returns:
            Tuple[bool, int]: Status of validation with the difference
        """
        func_name = inspect.stack()[0].function

        prev_assets = len(
            previous_df.index.get_level_values(level=PrimaryKey.assetid).unique()
        )
        curr_assets = len(
            current_df.index.get_level_values(level=PrimaryKey.assetid).unique()
        )
        difference = curr_assets - prev_assets
        abs_difference = abs(difference)

        percentage_difference = abs_difference / prev_assets

        if func_name in self.override_checks:
            return True, difference

        if percentage_difference > self.coverage_threshold:
            return False, difference

        return True, difference

    def check_limits(self, current_df: pd.DataFrame) -> bool:
        """
        Check to see if the values in the dataframe are within a defined range.
        If they are, we return True, else we return False

        Args:
            current_df (pd.DataFrame): current score dataframe

        Returns:
            bool: Staus of the validation check
        """
        func_name = inspect.stack()[0].function

        max_val = current_df.max().max()
        min_val = current_df.min().min()

        if func_name in self.override_checks:
            return True, min_val, max_val

        if max_val > self.upper_limit or min_val < self.lower_limit:
            return False, min_val, max_val
        return True, min_val, max_val

    def check_abs_diff(
        self, previous_df: pd.DataFrame, current_df: pd.DataFrame
    ) -> Tuple[bool, Dict[str, float]]:
        """
        This checks the absolute difference between the current and the previous
        calculation.
        If the difference is above a threshold it returns False with the max of each feature as a dict
        Otherwise it returns True with the maxes as a dict

        Args:
            previous_df (pd.DataFrame): previous calculation
            current_df (pd.DataFrame): current calculation

        Returns:
            Tuple[bool, Dict[str, float]]: Status of validation as well as dict of the maxes
        """
        func_name = inspect.stack()[0].function

        intersected_assets = previous_df.index.intersection(current_df.index).values
        previous_df = previous_df.loc[intersected_assets]
        current_df = current_df.loc[intersected_assets]

        delta_df = current_df.sub(previous_df).abs()
        max_changes = delta_df.max()

        if func_name in self.override_checks:
            return True, max_changes.to_dict()

        if (max_changes > self.abs_diff_threshold).any():
            return False, max_changes.to_dict()

        return True, max_changes.to_dict()

    def setup_custom_metrics(self) -> None:
        if not hasattr(self.prometheus, "job_coverage_failure"):
            self.prometheus.job_coverage_failure = Counter(
                "job_coverage_failure",
                "Counter of coverage failures",
                registry=self.prometheus.registry,
            )
        if not hasattr(self.prometheus, "job_abs_difference_failure"):
            self.prometheus.job_abs_difference_failure = Counter(
                "job_abs_difference_failure",
                "Counter of absolute difference failures",
                registry=self.prometheus.registry,
            )
        if not hasattr(self.prometheus, "job_value_bounds_failure"):
            self.prometheus.job_value_bounds_failure = Counter(
                "job_value_bounds_failure",
                "Counter of value bounds failures",
                registry=self.prometheus.registry,
            )

        if not hasattr(self.prometheus, "job_value_bounds_failure"):
            self.prometheus.job_value_bounds_failure = Counter(
                "job_value_bounds_failure",
                "Counter of coverage failures",
                registry=self.prometheus.registry,
            )

    def validate(self, prev_df: pd.DataFrame, curr_df: pd.DataFrame) -> bool:
        """
        Performs both both coverage as well as absolute difference validation checks.
        Should either return False, this will also return False. Otherwise True.

        When doing the absolute difference, it intersects the assets to show the difference
        of the same assets between the current calculation and previous.

        Args:
            prev_df (pd.DataFrame): previous calculation
            curr_df (pd.DataFrame): current calculation

        Returns:
            bool: Validation status
        """
        self.setup_custom_metrics()

        previous_df = prev_df.droplevel(level=PrimaryKey.date)
        current_df = curr_df.droplevel(level=PrimaryKey.date)

        valid_coverage, coverage_difference = self.check_coverage(
            previous_df, current_df
        )

        valid_bounds, min_val, max_val = self.check_limits(current_df)

        valid_diff, max_diffs = self.check_abs_diff(previous_df, current_df)

        if valid_coverage and valid_diff and valid_bounds:
            self.set_job_success()
            return True

        if not valid_coverage:
            log.error("Failed coverage check", coverage_difference=coverage_difference)

            self.prometheus.job_coverage_failure.inc()

        if not valid_diff:
            log.error("Failed absolute difference check", max_diffs=max_diffs)

            self.prometheus.job_abs_difference_failure.inc()

        if not valid_bounds:
            log.error(
                "Failed upper and lower limit bounds check",
                min_val=min_val,
                max_val=max_val,
            )

            self.prometheus.job_value_bounds_failure.inc()

        self.set_job_failure()
        return False
