from typing import List

import pandas as pd
from prometheus_client import Counter

from arabesque_py.score_validation.short_validator import ShortValidator


class EWMAValidator(ShortValidator):
    max_initial: float = 0.7
    min_initial: float = -1.3

    def get_decay_cols(self) -> List[str]:
        """
        Returns the list of column names which have _decay as the suffix

        Returns:
            List[str]: List of decay column names
        """
        return [f"{feature_col}_decay" for feature_col in self.feature_cols]

    def setup_custom_metrics(self) -> None:
        self.prometheus.ewma_large_movement = Counter(
            "ewma_large_movement",
            "Counter of the number of large movers above a threshold",
            registry=self.prometheus.registry,
        )

    def validate(self, curr_df: pd.DataFrame) -> bool:
        """
        This validates the daily ewma score in the following way:
        - Filters for current daily movers where decay is 0
        - Creates a boolean dataframe mask
        - Iterates over the dataframe, wherever nv_<feature>_decay is True, it sets nv_<feature>
            to also be True
        - Based on boolean dataframe mask it selects all the nv_<feature> cells which are being
            triggered by new news
        - Filters out the max and min initial values (-1.3 and 0.7)
        - Count the remaining which are above or below max_val and min_val respectively
        - If the count is above a threshold, we fail the validation

        Args:
            curr_df (pd.DataFrame): current calculation

        Returns:
            bool: Validation status
        """
        self.setup_custom_metrics()

        decay_cols = self.get_decay_cols()

        curr_df = curr_df[self.feature_cols + decay_cols]

        new_movers = curr_df[curr_df[decay_cols] == 0]

        new_movers_mask = new_movers.notna()
        for feature in self.feature_cols:
            feature_movers = new_movers_mask[f"{feature}_decay"][
                new_movers_mask[f"{feature}_decay"] == True
            ]
            if feature_movers.empty:
                continue

            new_movers_mask.loc[feature_movers.index.values, feature] = True

        filtered = curr_df[new_movers_mask]

        not_initial_min_max = filtered[
            (filtered != self.max_initial) & (filtered != self.min_initial)
        ]

        invalid_candidates = not_initial_min_max[
            (not_initial_min_max > self.max_val) | (not_initial_min_max < self.min_val)
        ].count(axis=1)

        if (invalid_candidates > self.threshold_count).any():
            self.prometheus.ewma_large_movement.inc()

            self.set_job_failure()
            return False

        self.set_job_success()
        return True
