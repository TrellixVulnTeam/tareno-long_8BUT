import time
from abc import ABCMeta, abstractmethod

import prometheus_client
import structlog
from google.api_core.exceptions import AlreadyExists
from google.cloud import pubsub_v1
from google.cloud.pubsub_v1 import SubscriberClient
from google.cloud.pubsub_v1.subscriber.futures import StreamingPullFuture
from google.cloud.pubsub_v1.subscriber.message import Message as PubSubMessage
from google.cloud.pubsub_v1.types import DeadLetterPolicy
from google.protobuf.message import Message as ProtobufMessage
from prometheus_client import Counter, Gauge, Histogram

from arabesque_py.prometheus import Prometheus

log = structlog.getLogger(__name__)


class Subscriber(metaclass=ABCMeta):
    """
    Represents a GCP PubSub subscriber

    Example::

        class TestSubscriber(Subscriber):
            def callback(self, message):
                try:
                    # parse message here
                    print(message.data)

                    # if message is protbuf then unpack it using the helper
                    p = ExampleProtobuf()
                    self.unpack_protobuf(p, message)

                    message.ack()
                except Exception:
                    message.nack()
        tc = TestConsumer("project", "topic", "sub")
        f = tc.subscribe()
        try:
            f.result()
        except KeyboardInterrupt:
            f.cancel()
    """

    project: str
    topic: str
    topic_name: str
    subscription: str
    subscription_name: str
    subscriber: SubscriberClient
    prometheus: Prometheus
    auto_metrics: bool
    sub_metric: bool = False
    dead_letter: bool = False
    dead_letter_topic: str
    dead_letter_policy: DeadLetterPolicy
    max_delivery_attempts: int = 5

    def __init__(
        self,
        project: str,
        topic: str,
        subscription: str,
        prometheus: Prometheus = None,
        auto_metrics: bool = False,
        dead_letter: bool = False,
        dead_letter_topic: str = None,
        max_delivery_attempts: int = 5,
    ):
        """
        Args:
            project: The GCP project ID
            topic: The topic to consume
            subscription: The subscription to consume
            prometheus: A prometheus instance
            auto_metrics: If set will register and log pre-defined metrics.
            dead_letter: Whether to use dead letter functionality or not
            dead_letter_topic: The topic for dead letter
            max_delivery_attempts: How many retries messages will have before they are sent to dead letter
        Returns:
            object:
        """
        self.project = project
        self.subscriber = pubsub_v1.SubscriberClient()

        self.topic = self.subscriber.topic_path(project, topic)
        self.subscription = self.subscriber.subscription_path(project, subscription)

        if prometheus is not None and auto_metrics:
            self.sub_metric = True
            self.prometheus = prometheus
            self.setup_prometheus()

        self.dead_letter_policy = None
        if dead_letter and dead_letter_topic is not None:
            dead_letter_topic_path = self.subscriber.topic_path(
                project, dead_letter_topic
            )
            self.max_delivery_attempts = max_delivery_attempts
            self.dead_letter_policy = DeadLetterPolicy(
                dead_letter_topic=dead_letter_topic_path,
                max_delivery_attempts=max_delivery_attempts,
            )

        try:
            self.subscriber.create_subscription(
                self.subscription,
                self.topic,
                dead_letter_policy=self.dead_letter_policy,
            )
        except AlreadyExists:
            pass

        log.info(
            f"setup pubsub subscriber complete - topic: {self.topic} subscription: {self.subscription}"
        )

    def subscribe(self) -> StreamingPullFuture:
        """
        Subscribes to the set project/topic

        Returns:
            StreamingPullFuture: A future instance
        """

        log.info(f"subscribed to topic: {self.topic} subscription: {self.subscription}")
        return self.subscriber.subscribe(self.subscription, self._callback)

    def _callback(self, message: PubSubMessage):
        """
        This is the private callback function we use to see if we need to push
        metrics for this message

        Args:
            message: Our pubsub message
        """
        start_time = time.time()

        logger = log.new(pubsub_id=message.message_id)
        logger.info(
            f"pubsub message received",
            pubsub_id=message.message_id,
            topic=self.topic,
            subscription=self.subscription,
            pubsub_message_publish_time=message.publish_time.timestamp(),
        )

        if not self.sub_metric:
            self.callback(message)

            time_taken = time.time() - start_time
            logger.info(f"pubsub message processed in {time_taken * 1000:.0f}ms")
            return

        self.prometheus.pubsub_consumed_messages.labels(
            project_id=self.project, topic=self.topic, subscription=self.subscription
        ).inc()
        self.prometheus.pubsub_consumer_processing_message.labels(
            project_id=self.project, topic=self.topic, subscription=self.subscription
        ).inc()

        ack = self.callback(message)
        time_taken = time.time() - start_time

        self.prometheus.pubsub_consumer_processing_message.labels(
            project_id=self.project, topic=self.topic, subscription=self.subscription
        ).dec()

        if ack:
            logger.info(f"acknowledged pubsub message")

            status = "ack"
            message.ack()

            if (
                self.dead_letter_policy is not None
                and message.delivery_attempt is not None
            ):
                self.prometheus.pubsub_delivery_attempt_message.labels(
                    project_id=self.project,
                    topic=self.topic,
                    subscription=self.subscription,
                    delivery_attempt=message.delivery_attempt,
                ).inc()
        else:
            logger.info(f"not-acknowledged pubsub message")

            status = "nack"
            message.nack()

            if message.delivery_attempt is not None and (
                message.delivery_attempt >= self.max_delivery_attempts
            ):
                self.prometheus.pubsub_consumer_dead_letter_message.labels(
                    project_id=self.project,
                    topic=self.topic,
                    subscription=self.subscription,
                ).inc()

        self.prometheus.pubsub_consumer_processed_message.labels(
            project_id=self.project,
            topic=self.topic,
            subscription=self.subscription,
            status=status,
        ).inc()
        self.prometheus.pubsub_consumer_processing_time.labels(
            project_id=self.project,
            topic=self.topic,
            subscription=self.subscription,
            status=status,
        ).observe(time_taken)

        logger.info(f"pubsub message processed in {time_taken * 1000:.0f}ms")

    @abstractmethod
    def callback(self, message: PubSubMessage) -> bool:
        """
        The callback to run on every consumed message - remember to `message.ack()`
        or `message.nack()`

        Args:
            message: The pubsub message

        Returns:
            success: Has the message been consumed successfully, if true - then
            ack the message, else nack the message.
        """
        pass

    @staticmethod
    def unpack_protobuf(protobuf: ProtobufMessage, message: PubSubMessage):
        """
        Unpacks a pubsub message into a protobuf

        Args:
            protobuf: The protobuf you want to parse the pubsub message into
            message: The pubsub message
        """
        protobuf.ParseFromString(message.data)
        return protobuf

    def setup_prometheus(self):
        """
        This sets up various useful metrics if `self.prometheus` and
        `self.auto_metrics` is set. The following metrics are registered:

        - `pubsub_consumed_messages`: This is a counter of consumed messages
        - `pubsub_consumer_running`: This is a counter of how many consumers we
        have running.
        - `pubsub_consumer_processing_message`: This is a gauge of how many
        messages we are currently processing.
        - `pubsub_consumer_processed_message`: This is a counter of how many
        messages we've processed.
        -  `pubsub_consumer_processing_time`: This is a histogram of how long
        it takes us to consume a message
        """

        registry = (
            self.prometheus.registry
            if self.prometheus.registry is not None
            else prometheus_client.REGISTRY
        )

        # We need to check if prometheus has these attributes due to multiple
        # subscribers might be registered
        if not hasattr(self.prometheus, "pubsub_consumed_messages"):
            self.prometheus.pubsub_consumed_messages = Counter(
                "pubsub_consumed_messages",
                "Counter of pubsub consumed messages",
                ["project_id", "topic", "subscription"],
                registry=registry,
            )

        if not hasattr(self.prometheus, "pubsub_consumer_running"):
            self.prometheus.pubsub_consumer_running = Gauge(
                "pubsub_consumer_running",
                "Counter of pubsub consumer running - useful for debugging how many consumers you have running for project_id/topic/subscription",
                ["project_id", "topic", "subscription"],
                registry=registry,
                multiprocess_mode="liveall",
            )

        if not hasattr(self.prometheus, "pubsub_consumer_processing_message"):
            self.prometheus.pubsub_consumer_processing_message = Gauge(
                "pubsub_consumer_processing_message",
                "Gauge of messages currently being processed",
                ["project_id", "topic", "subscription"],
                registry=registry,
                multiprocess_mode="liveall",
            )

        if not hasattr(self.prometheus, "pubsub_consumer_processed_message"):
            self.prometheus.pubsub_consumer_processed_message = Counter(
                "pubsub_consumer_processed_message",
                "Counter of pubsub messages processed with ACK/NACK status",
                ["project_id", "topic", "subscription", "status"],
                registry=registry,
            )

        if not hasattr(self.prometheus, "pubsub_consumer_dead_letter_message"):
            self.prometheus.pubsub_consumer_dead_letter_message = Counter(
                "pubsub_consumer_dead_letter_message",
                "Counter of pubsub messages dropped and published to the dead letter queue",
                ["project_id", "topic", "subscription"],
                registry=registry,
            )

        if not hasattr(self.prometheus, "pubsub_delivery_attempt_message"):
            self.prometheus.pubsub_delivery_attempt_message = Counter(
                "pubsub_consumer_delivery_attempt_message",
                "Counter of pubsub messages delivery attempts before ACK",
                ["project_id", "topic", "subscription", "delivery_attempt"],
                registry=registry,
            )

        if not hasattr(self.prometheus, "pubsub_consumer_processing_time"):
            self.prometheus.pubsub_consumer_processing_time = Histogram(
                "pubsub_consumer_processing_time",
                "Histogram of how long it took to consume a message with ACK/NACK status",
                ["project_id", "topic", "subscription", "status"],
                registry=registry,
            )

        self.prometheus.pubsub_consumer_running.labels(
            project_id=self.project, topic=self.topic, subscription=self.subscription
        ).inc()
