import threading
from abc import ABCMeta

from arabesque_py.prometheus import Prometheus
from arabesque_py.subscriber.subscriber import Subscriber


class ThreadedSubscriber(threading.Thread, Subscriber, metaclass=ABCMeta):
    """Represents a GCP PubSub threaded subscriber

    Example::

        class TestThreadedSubcriber(ThreadedSubscriber):
            try:
                # parse message here
                print(message.data)

                # if message is protbuf then unpack it using the helper
                p = ExampleProtobuf()
                self.unpack_protobuf(p, message)

                message.ack()
            except Exception:
                message.nack()
        pubsub_receiver = TestSubMulti("project", "topic", "sub")
        pubsub_receiver.start()
    """

    alive: bool = False

    def __init__(
        self,
        project: str,
        topic: str,
        subscription: str,
        prometheus: Prometheus = None,
        auto_metrics: bool = False,
        dead_letter: bool = False,
        dead_letter_topic: str = None,
        max_delivery_attempts: int = 5,
    ):
        """
        Args:
            project: The GCP project ID
            topic: The topic to consume
            subscription: The subscription to consume
            prometheus: A prometheus instance
            auto_metrics: If set will register and log pre-defined metrics.
            dead_letter: Whether to use dead letter functionality or not
            dead_letter_topic: The topic for dead letter
            max_delivery_attempts: How many retries messages will have before they are sent to dead letter
        Returns:
            object:
        """
        Subscriber.__init__(
            self,
            project,
            topic,
            subscription,
            prometheus,
            auto_metrics,
            dead_letter,
            dead_letter_topic,
            max_delivery_attempts,
        )
        threading.Thread.__init__(self)

    def run(self):
        """
        Starts running the thread process
        """
        self.alive = True
        future = self.subscribe()
        try:
            while self.alive:
                future.result()
        finally:
            future.cancel()

    def stop(self):
        """
        Stops the threaded process
        """
        self.alive = False
        self.join()
