import os
from typing import Any

import prometheus_client
from prometheus_client import Counter, push_to_gateway
from prometheus_client.registry import CollectorRegistry
from structlog import get_logger

from arabesque_py.prometheus.http_client import DEFAULT_PATH

STATUS_KEY = "status"
STATUS_SUCCESS = "success"
STATUS_FAILED = "failed"
UNKNOWN_VALUE = "unknown"

log = get_logger()


class Prometheus:
    """
    Represents a Prometheus handler, that can handle the metrics, as well as the
    HTTP client and the middleware.

    It is suggested that you use this class as a base class so you can add your
    own metrics if needed, else if not just use the base class.

    Example::

        class TestProm(Prometheus):
            def __init__(self):
                super().__init__()
                self.r_req = Counter(
                    'R_req',
                    'Counter of R HTTP requests',
                    registry=self.registry)


        class Resource(object):
            def on_get(self, req, resp):
                prom.r_req.inc()
                resp.status = falcon.HTTP_200


        prom = TestProm()
        api = falcon.API(middleware=prom.middleware)

        # Can attach middleware by defining path
        api.add_route(DEFAULT_PATH, prom.http_client)

        # Or by do it automatically with the predefined path
        prom.http_client.attach(api)

        res = Resource()
        api.add_route('/res', res)
    """

    registry: CollectorRegistry
    threaded: bool = False
    multiproc_dir: str = None
    metrics_path: str = None
    gateway: str = None

    def __init__(
        self,
        metrics_path: str = DEFAULT_PATH,
        threaded: bool = True,
        version: str = None,
        gateway: str = None,
    ):
        """
        Args:
            metrics_path: The path that the metrics will be accessible for
            prometheus - i.e. /_internal/metrics
        """
        self.registry = CollectorRegistry(auto_describe=True)
        self.metrics_path = metrics_path
        self.gateway = gateway

        if threaded and "prometheus_multiproc_dir" in os.environ:
            if "prometheus_multiproc_dir" not in os.environ:
                raise KeyError(
                    "The prometheus environment variable for multi-process dir is not set: prometheus_multiproc_dir"
                )

            self.registry = None
            self.threaded = True
            self.multiproc_dir = os.environ.get("prometheus_multiproc_dir")
            if not os.path.exists(self.multiproc_dir):
                os.makedirs(self.multiproc_dir, exist_ok=True)

        registry = (
            self.registry if self.registry is not None else prometheus_client.REGISTRY
        )
        self.service_build_version = Counter(
            "service_build_version",
            "Counter of the currently running version of this service",
            ["version"],
            registry=registry,
        )

        if version is not None:
            self.service_build_version.labels({"version": version}).inc()

    def push(self, app_name: str, grouping_key: Any = None) -> None:
        """
        This allows for functionality to push metrics to prometheus via pushgateway

        Args:
            app_name (str): label for job or app
        """

        # Log error for no gateway defined but don't throw exception here as not
        # worth raising an exception just for metrics breaking
        if self.gateway is None:
            log.error("PushGateway not set, can't send metrics")
            return

        push_to_gateway(
            self.gateway,
            job=app_name,
            registry=self.registry,
            grouping_key=grouping_key,
        )
