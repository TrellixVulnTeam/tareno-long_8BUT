import typing
from dataclasses import dataclass


@dataclass(frozen=True)
class DictAttribute:
    """
    DictAttribute is a helper class for BiDirectionalDictMapping, where a DictAttribute instance is the reference to a
    dictionary attribute (key).
    """

    key: str

    @property
    def path(self) -> typing.List[str]:
        return self.key.split(".")

    def get_value(self, data: typing.Dict) -> bool:
        value = data
        for key in self.path:
            try:
                value = value[key]
            except KeyError:
                raise KeyError(f"{self.key} not defined")

        return value

    def is_defined(self, data: typing.Dict) -> bool:
        try:
            self.get_value(data)
            return True
        except KeyError:
            return False

    def set_value(self, data: typing.Dict, value: typing.Any):
        depth = len(self.path)
        for i, key in enumerate(self.path):
            if i + 1 != depth:
                #  Nested
                data[key] = data.get(key, {})
                data = data[key]
            else:
                data[key] = value


@dataclass(frozen=True)
class BiDirectionalDictMapping:
    """A BiDirectionalDictMapping defines a relationship between multiple dictionary keys (DictAttribute),
    and given a dictionary can map the common value these keys share (if any) to all keys that are not defined in the
    given dictionary

    Nested dictionaries are supported through dot notation (e.g. `some_dict['some.nested.key']` is equivalent to
    `some_dict['some']['nested']['key']`).

    This logic is used by the AppSchema and FieldSchema to allow the bidirectional mapping between the flattened and
    nested definitions (i.e., the equivalence between `AppSchema().load({'name': 'ESG', 'version': (2, 6, 2, 0)})` and
    `AppSchema().load({'unversioned_app: {'name': 'ESG'}, 'version': (2, 6, 2, 0)})`

    Example:
        In this example, we decide that a dictionaries values for `flattened_key_1` and `keys.1` should be equivalent,
        so when we map a dictionary than only contains one of the keys (e.g. `flattened_key_1`), the related key
        (`keys.1`) should receive the same value.
        ```
        from arabesque_py.sray_db.schema.mapper import BiDirectionalDictMapping, DictAttribute

        mapping = BiDirectionalDictMapping(
            attributes = [
               DictAttribute('flattened_key_1'),
               DictAttribute('key.1')
            ]
        )
        dataset = {'flattened_key_1': 'some_val'}
        print(dataset)  # Output: {'flattened_key_1': 'some_val'}
        mapping.map_data(dataset)
        print(dataset)  # Output: {'flattened_key_1': 'some_val', 'key': {'1': 'some_val'}}
        ```
    """

    attributes: typing.List[DictAttribute]

    def __post_init__(self):
        self._cast_attributes_type()

    def _cast_attributes_type(self):
        for i, attribute in enumerate(self.attributes):
            if not isinstance(attribute, DictAttribute):
                self.attributes[i] = DictAttribute(attribute)

    def get_defined_attributes(self, data: typing.Dict) -> typing.List[DictAttribute]:
        return [a for a in self.attributes if a.is_defined(data)]

    def get_undefined_attributes(self, data: typing.Dict) -> typing.List[DictAttribute]:
        return [a for a in self.attributes if not a.is_defined(data)]

    def get_unique_values(self, data: typing.Dict) -> typing.Set[typing.Any]:
        unique_values = []
        for attribute in self.get_defined_attributes(data):
            value = attribute.get_value(data)
            if value not in unique_values:
                unique_values.append(value)

        return unique_values

    def get_common_value(self, data: typing.Dict) -> typing.Any:
        unique_values = self.get_unique_values(data)
        if len(unique_values) > 1:
            raise ValueError(
                f"{self} is not uniquely defined for the dataset (found unique values {unique_values})"
            )

        common_value = next(iter(unique_values))

        return common_value

    def is_any_attribute_defined(self, data: typing.Dict) -> bool:
        return len(self.get_defined_attributes(data)) > 0

    def map_data(self, data: typing.Dict) -> typing.List[DictAttribute]:
        if not self.is_any_attribute_defined(data):
            return []

        common_value = self.get_common_value(data)

        updated_attributes = []
        for attribute in self.get_undefined_attributes(data):
            attribute.set_value(data, common_value)
            updated_attributes.append(attribute)

        return updated_attributes


def map_bidirectionally(data: typing.Dict, attributes: typing.List[str]) -> None:
    """
    Performs an inplace update on the `data` dictionary, bidirectionally mapping values in the `data` dictionary across
    all keys defined in the `attributes`

    See BiDirectionalDictMapping docstring for a more detailed description and example.
    :param data: dictionary on which the bidirectional mapping is applied
    :param attributes: list of dictionary keys (string references) for which a bidirectional equivalence is established
    """
    mapping = BiDirectionalDictMapping(attributes)
    mapping.map_data(data)
