import typing

import marshmallow as ma

from arabesque_py.sray_db import IS_SRAY_DB_INSTALLED
from arabesque_py.sray_db.schema.app import AppSchema
from arabesque_py.sray_db.schema.mapper import map_bidirectionally


class FieldSchema(ma.Schema):
    """
    References an existing Field instance that is declared in the AppRegistry

    Example:
        from arabesque_py.sray_db import FieldSchema
        field = FieldSchema().load({'name': 'esg', 'app_name': 'ESG', 'app_version': (2, 6, 2, 0)})
        print(field)  # Output: <Field esg on <App ESG (2.6.2.0)>>
        print(FieldSchema(load_only=['app']).dump(field))  # Output: {'app_name': 'ESG', 'name': 'esg', 'app_version': (2, 6, 2, 0)}
    ```
    """

    app_name = ma.fields.String(
        attribute="app.name",
    )
    app_version = ma.fields.Tuple(
        [ma.fields.Integer()] * 4,
        attribute="app.version",
    )
    name = ma.fields.String(
        required=True,
    )
    app = ma.fields.Nested(AppSchema(), required=True)

    @ma.pre_load
    def _expand_data(self, data, **kwargs):
        """
        For usability, the nested data from the `app` field is automatically mapped bidirectionally to
        the `app_name` and `app_version` fields, so the user is free to specify the app either with a nested `app`
        object or with `app_name` and `app_version` strings as a reference to the App. Both approaches are equivalent.
        """
        map_bidirectionally(data=data, attributes=["app_name", "app.name"])
        map_bidirectionally(data=data, attributes=["app_version", "app.version"])

        # The flattened fields should never overwrite the attributes of the nested field after the nested field has
        # already been loaded, since this can lead to unexpected side effects (bypassing the nested object's loading
        # and initialization logic). Since marshmallow loads the fields in random order, we enforce that the flattened
        # fields are never used to be directly assigned to the nested object by removing them from the dataset before
        # loading.
        for attr in ["app_name", "app_version"]:
            data.pop(attr, None)

        return data

    @ma.post_load
    def make_field(self, data: typing.Dict, **kwargs) -> "sray_db.apps.field.Field":
        """Return an sray_db Field instance if sray_db is installed, else just pass on the data"""
        if not IS_SRAY_DB_INSTALLED:
            return data

        app, field_name = data["app"], data["name"]
        field = app[field_name]

        return field
